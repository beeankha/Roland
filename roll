#!/bin/env perl
use 5.12.0;
use warnings;

use Data::Bucketeer;
use Games::Dice qw(roll);
use Getopt::Long::Descriptive;
use List::AllUtils qw(sum);
use YAML::Tiny;

my $ROLLER;

my $XP_LOOKUP = Data::Bucketeer->new('>=' => {
  0.9 => sub { [    5,    1 ] },
  1.0 => sub { [   10,    1 ] },
  1.1 => sub { [   15,    1 ] },
  2.0 => sub { [   20,    5 ] },
  2.1 => sub { [   25,   10 ] },
  3.0 => sub { [   50,   15 ] },
  3.1 => sub { [   50,   25 ] },
  4.0 => sub { [   75,   50 ] },
  4.1 => sub { [  125,   75 ] },
  5.0 => sub { [  175,  125 ] },
  5.1 => sub { [  225,  175 ] },
  6.0 => sub { [  350,  225 ] },
  6.1 => sub { [  350,  300 ] },
  7.0 => sub { [  450,  400 ] },
  8.0 => sub { [  650,  550 ] },
  9.0 => sub { [  900,  700 ] },
  11  => sub { [ 1100,  800 ] },
  13  => sub { [ 1350,  950 ] },
  17  => sub { [ 2000, 1150 ] },
  21  => sub {
    my $hd   = int $_;
    my $over = $hd - 21;
    return [
      2500 + 250 * $over,
      2000,
    ];
  },
});

sub xp_for_monster {
  my ($self, $monster) = @_;
  my $bonuses = @{ $monster->{'XP Bonuses'} // [] };

  return 0 unless my $hd = $monster->{Stats}{'Hit Dice'};
  my ($dice, $sign, $bonus) = split /\s+/, $hd, 3;
  $bonus = ($sign || $bonus) ? "$sign$bonus" : 0;

  if ($dice =~ /d/) {
    my ($num, $type) = split /d/, $dice, 2;
    die "confused about hit dice: $hd" if $type != 8 and $num != 1;
    if ($type > 8) { $bonus = 1  };
    if ($type < 8) { $bonus = -1 }
    $dice = $num;
  }

  my $d8 = $dice;
  $d8 += $bonus > 0 ? .1 : $bonus < 0 ? -.1 : 0;

  my $pair = $XP_LOOKUP->result_for($d8);
  return($pair->[0] + $pair->[1] * $bonuses);
}

sub resolve_monster {
  my ($self, $path) = @_;
  return "(missing file, monsters/$path)" unless -e "monsters/$path"; # XXX
  my $data = YAML::Tiny->read("monsters/$path");
  die $YAML::Tiny::errstr unless $data;
  my $main = shift @$data;
  my $name = $main->{Name} // $path;
  my $num_dice = $main->{Stats}{'No. Appearing'} // '?';
  $num_dice = $num_dice->{wandering} if ref $num_dice;
  my $num = $num_dice =~ /d/ ? $ROLLER->($num_dice, "number of $name")
                             : $num_dice;

  my $HD = $main->{Stats}{'Hit Dice'} // '?';
  my @hd = split /\s+/, $HD;
  my $hd = do {
    local $" = '';
    my $d = $hd[0] !~ /d/ ? 'd8' : '';
    "$hd[0]$d@hd[ 1 .. $#hd]"
  };

  my @units = $num eq '?'
            ? ()
            : map {; { hp => $ROLLER->($hd, "$name \#$_ hp") } } 1 .. $num;

  my %extra;
  for my $extra (@$data) {
    my $desc = $extra->{description};

    if ($extra->{'per-unit'}) {
      UNIT: for my $unit (@units) {
        my $result = $self->roll_table($extra, "$name/$desc");
        if ($result->{is_redirect}) {
          $unit = $result->{text};
          next UNIT;
        }

        $unit->{ $desc } = $result->{text};
      }
    } else {
      my $result = $self->roll_table($extra, "$name/$desc");
      return $result->{text} if $result->{is_redirect};
      $extra{ $desc } = $result->{text};
    }
  }

  my $ac  = $main->{Stats}{'Armor Class'} // '?';
  my $mv  = $main->{Stats}{Movement}      // '?';
  my $dmg = $main->{Stats}{Damage}        // '?';

  my $xp   = $self->xp_for_monster($main) || '?';
  my $xp_t = $xp eq '?' ? '?' : $num * $xp;

my $text = <<"END_MONSTER";

$name
  No. Appearing: $num
  Hit Dice: $HD
  Stats: [ AC $ac, Mv $mv, Dmg $dmg ]
  Total XP: $xp_t ($num x $xp xp)
END_MONSTER

  for my $key (sort keys %extra) {
    next unless defined $extra{$key};
    $text .= "  $key: $extra{$key}\n";
  }

  for my $unit (@units) {
    if (ref $unit) {
      my $hp = delete $unit->{hp};
      $text .= "- Hit points: $hp\n";
      for my $key (sort keys %$unit) {
        next unless defined $unit->{$key};
        $text .= "  $key: $unit->{ $key }\n";
      }
    } else {
      my $unit_text = $unit;
      $unit_text =~ s/^/  /mg;
      substr $unit_text, 0, 1, '-';
      $text .= $unit_text;
    }
  }

  return $text
}

sub resolve_table {
  my ($self, $table) = @_;
  $self->format_result( $self->roll_table_file($table) );
}

sub roll_table_file {
  my ($self, $fn) = @_;
  my $data = YAML::Tiny->read($fn);
  die "error in $fn: $YAML::Tiny::errstr" unless $data;
  $self->roll_table( $data->[0], $fn );
}

sub roll_table {
  my ($self, $table, $name) = @_;
  $name //= "?";
  my @dice_str = split / \+ /, $table->{dice};
  my $result = sum 0, map { $ROLLER->($_, $name) } @dice_str;

  my %case;
  for my $key (keys %{ $table->{results} }) {
    if ($key =~ /-/) {
      my ($min, $max) = split /-/, $key;
      $case{ $_ } = $table->{results}{$key} for $min .. $max;
    } else {
      $case{ $key } = $table->{results}{$key};
    }
  }

  my $payload = $case{ $result };

  my ($method, $arg) = $self->_plan_for_string($payload);
  my $is_redirect = $method eq 'resolve_goto';
  my $text = $self->$method($arg, $table, $name);

  return {
    dice => $result,
    text => $text,
    is_redirect => $is_redirect,
  };
}

sub _plan_for_string {
  my ($self, $string) = @_;
  my ($type, $rest) = split /\s+/, $string, 2;

  my $method = $type eq 'M' ? 'resolve_monster'
             : $type eq 'T' ? 'resolve_table'
             : $type eq 'x' ? 'resolve_multi'
             : $type eq 'G' ? 'resolve_goto'
             : $type eq '=' ? sub { $_[1] }
             :                sub { $_[1] };

  return ($method, $rest);
}

sub resolve_goto {
  my ($self, $string, $table, $name) = @_;

  my ($method, $arg) = $self->_plan_for_string($string);
  my $text = $self->$method($arg, $table, $name);
}

sub resolve_multi {
  my ($self, $x, $table, $name) = @_;
  # XXX: no, this should get a list of [ $table, $name ] tuples to combine or
  # something -- rjbs, 2012-11-27

  my @results = map { $self->roll_table($table, $name) } (1 .. $x);
  return join "", map {; "\n" . $self->format_result($_, 1) } @results;
}

my ($opt, $usage) = describe_options(
  '%c %o <table>',
  [ 'manual|m', 'enter die rolls manually' ],
  [ 'mode=s',   'table mode', { default => 'table' } ],
);

if ($opt->manual) {
  $ROLLER = sub {
    local $| = 1;
    my $dice = $_[0];
    $dice .= " for $_[1]" if $_[1];
    my $default = roll($_[0]);
    print "rolling $dice [$default]: ";
    my $result = <STDIN>;
    chomp $result;
    $result = $default unless length $result;
    return $result;
  };
} else {
  $ROLLER = sub {
    my ($dice, $desc) = @_;
    my $result = roll($dice);
    print "rolled $dice for $desc: $result\n";
    return $result;
  };
}

sub format_result {
  my ($self, $result, $indent) = @_;
  my $string = <<"END_STRING";
rolled: $result->{dice}
result: ($result->{type}) $result->{text}
END_STRING

  $string =~ s{^}
              {'  ' x ($indent // 0)}egm;
  return $string;
}

if ($opt->mode eq 'table') {
  say "rolled on $ARGV[0]";
  say main->resolve_table($ARGV[0]);
} elsif ($opt->mode eq 'monster') {
  say main->resolve_monster($ARGV[0]);
} else {
  die "unknown mode" unless $opt->mode eq 'table';
}
